# -------------------------------------------------------------------------------
# Copyright (c) 2010 Plextek Limited, Great Chesterford, England.
# All Rights Reserved
# -------------------------------------------------------------------------------
# THIS FILE IS VERSION CONTROLLED USING SVN. DO NOT HAND EDIT THESE FIELDS
# -------------------------------------------------------------------------------
# $HeadURL: http://mantis/svn/projects/Spies/Ames/Src/x1S00/tags/Release_3.3/test/src/gencodes.py $
# $Revision: 5700 $
# $Author: pdm $
# $Date: 2011-05-18 12:29:56 +0100 (Wed, 18 May 2011) $
# -------------------------------------------------------------------------------
# File Description (User Field)
# ----------------------------
##
# \file gencodes.py
# \brief Generate scrambling codes
#
# If this module is run as a script
# (if __name__ == "__main__" section is executed)
# we generate a c++ header
# containing some pre-calculated tables.
# It is also used by test utilities as a module for a source of scrambling codes.
## 
# \namespace gencodes
# \brief The gencodes.py module contains functions to generate scrambling codes

#-------------------------------------------------------------------------------

import cmath
from numpy import array, conjugate, array_str
from numpy.fft import fft
import sys

def gen_psc():
    """primary scrambling code see 25.213"""
    a = array([ 1, 1, 1, 1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1, 1 ])
    t = array([ a, a, a, -a, -a, a, -a, -a , a, a, a, -a, a, -a, a, a ]).flatten()
    return t*(1+1j)


def gen_psc_fft_coef():
    """return conjugate fft of pcs"""
    return conjugate( fft( gen_psc() ) )


def gen_uplink_scramble_long( code ):
    """Long uplink scrambling code"""
    x = (code&0x00ffffff)|0x01000000
    y = 0x01ffffff
    ans = []
    clong2prev = 0
    for i in range( 38400 ):
        x0 = x & 1
        xc2 = ((x>>4) ^ (x>>7) ^ (x>>18))&1
        x25 = x0 ^ ((x>>3)&1)
        x = (x >> 1) | (x25<<24)
        y0 = y & 1
        yc2 = ( (y>>4) ^ (y>>6) ^ (y>>17) )&1
        y25 = (y0 ^ (y>>1) ^ (y>>2) ^ (y>>3))&1
        y = (y >> 1) | (y25<<24)
        clong1 = (x0^y0)*-2 + 1
        clong2 = (xc2^yc2)*-2 + 1
        if i%2 == 0:
            clong = float(clong1)*( 1.0 + 1j*clong2 )
        else:
            clong = float(clong1)*( 1.0 - 1j*clong2prev )
        clong2prev = clong2
        ans.append(complex(clong))
    return ans

def gen_downlink_scramble_x_init( n ):
    """Iterate x n times to find x(n)
    which will be used as the starting point for zn(i)
    """
    x = 0x01
    for i in range( n ):
        x18 = ((x) ^ (x>>7)) & 1
        x = (x>>1) | (x18<<17)
    return x
    

def gen_downlink_scramble( n ):
    """Downling scrambling code generator"""
    x = gen_downlink_scramble_x_init( n )
    y = 0x0003ffff
    Sdl = []
    for i in range( 38400 ):
        x0 = x & 1
        xx = ((x>>15) ^ (x>>6) ^ (x>>4)) & 1
        x18 = ((x) ^ (x>>7)) & 1
        x = (x>>1) | (x18<<17)
        y0 = y & 1
        yy = ((y>>15) ^ (y>>14) ^ (y>>13) ^ (y>>12) ^ (y>>11) ^ (y>>10) ^ (y>>9) ^ (y>>8) ^ (y>>6) ^ (y>>5)) & 1
        y18 = ((y) ^ (y>>5) ^ (y>>7) ^ (y>>10)) & 1
        y = (y>>1) | (y18<<17)
        zr = float( x0^y0 ) *-2 + 1
        zi = float( xx^yy ) *-2 + 1
        Sdl.append( zr + 1j*zi )
    return Sdl



## Returns a string in format real,imaj,real,imag 
#  with numbers as integers scaled by factor
#  \param [in] a the array
#  \param [in] factor mulitply data by this factor
#  \param [in] col_pairs number of pairs per line
#  \param [in] width min field width
def array_int_string( a, factor=1, col_pairs=4, width=6 ):
    a *= factor
    s=""
    format="%%%dd,%%%dd"%(width,width)
    c = 0
    for aa in a:
        s+=format%(aa.real, aa.imag)
        c+=1
        if c == len(a):
            pass
        elif c%col_pairs == 0:
            s += ',\n'
        else:
            s += ', '
    return s


## \cond undocumented
# if this module is run as a script we generate a c++ header
# containing some pre-calculated tables
if __name__ == "__main__":
    
    psc = gen_psc()
    psc_str = array_int_string( psc, col_pairs = 8, width = 2 )
    
    xinit = ""
    for i in range( 512 ):
        xinit += "0x%x"%(gen_downlink_scramble_x_init(i*16))
        if i != 511: xinit += ', '
        if i%8 == 7 : xinit += '\n'

    if len(sys.argv) > 1:
        filename = sys.argv[1]
    else:
        print "enter filename on command line, generating tables.hpp"
        filename = "tables.hpp"
    file = open( filename, 'w' )

    file.write( """
// auto generated by gencodes.py
// do not edit this file directly
#ifndef __TABLES_HPP__
#define __TABLES_HPP__
#include <stdint.h>

namespace Tables{

size_t const psc_len = %d; // number of re, im pairs
// re, im, re, im, ...
int32_t const psc[] = {
%s
};

uint32_t const primary_dlscram_xinit[] = {
%s};

}
#endif
"""%(len(psc), psc_str, xinit )
)

## \endcond
